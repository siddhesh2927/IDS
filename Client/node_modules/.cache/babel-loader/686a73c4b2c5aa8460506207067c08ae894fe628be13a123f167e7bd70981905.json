{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nexport function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {\n  // Static current data\n  let currentTotalPtg = 0;\n  const undefinedIndexes = [];\n  ptgSizes.forEach((size, index) => {\n    if (size === undefined) {\n      undefinedIndexes.push(index);\n    } else {\n      currentTotalPtg += size;\n    }\n  });\n  const restPtg = 1 - currentTotalPtg;\n  const undefinedCount = undefinedIndexes.length;\n  // If all sizes are defined but don't sum to 1, scale them.\n  if (ptgSizes.length && !undefinedIndexes.length && currentTotalPtg !== 1) {\n    // Handle the case when all sizes are 0\n    if (currentTotalPtg === 0) {\n      const avg = 1 / ptgSizes.length;\n      return ptgSizes.map(() => avg);\n    }\n    const scale = 1 / currentTotalPtg;\n    // We know `size` is a number here because undefinedIndexes is empty.\n    return ptgSizes.map(size => size * scale);\n  }\n  // Fill if exceed\n  if (restPtg < 0) {\n    const scale = 1 / currentTotalPtg;\n    return ptgSizes.map(size => size === undefined ? 0 : size * scale);\n  }\n  // Check if limit exists\n  let sumMin = 0;\n  let sumMax = 0;\n  let limitMin = 0;\n  let limitMax = 1;\n  for (const index of undefinedIndexes) {\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    sumMin += min;\n    sumMax += max;\n    limitMin = Math.max(limitMin, min);\n    limitMax = Math.min(limitMax, max);\n  }\n  // Impossible case, just average fill\n  if (sumMin > 1 && sumMax < 1) {\n    const avg = 1 / undefinedCount;\n    return ptgSizes.map(size => size === undefined ? avg : size);\n  }\n  // Quickly fill if can\n  const restAvg = restPtg / undefinedCount;\n  if (limitMin <= restAvg && restAvg <= limitMax) {\n    return ptgSizes.map(size => size === undefined ? restAvg : size);\n  }\n  // Greedy algorithm\n  const result = _toConsumableArray(ptgSizes);\n  let remain = restPtg - sumMin;\n  for (let i = 0; i < undefinedCount; i += 1) {\n    const index = undefinedIndexes[i];\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    result[index] = min;\n    const canAdd = max - min;\n    const add = Math.min(canAdd, remain);\n    result[index] += add;\n    remain -= add;\n  }\n  return result;\n}","map":{"version":3,"names":["_toConsumableArray","autoPtgSizes","ptgSizes","minPtgSizes","maxPtgSizes","currentTotalPtg","undefinedIndexes","forEach","size","index","undefined","push","restPtg","undefinedCount","length","avg","map","scale","sumMin","sumMax","limitMin","limitMax","min","max","Math","restAvg","result","remain","i","canAdd","add"],"sources":["C:/Users/ASUS/Desktop/Intrusion Detction System/Client/node_modules/antd/es/splitter/hooks/sizeUtil.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nexport function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {\n  // Static current data\n  let currentTotalPtg = 0;\n  const undefinedIndexes = [];\n  ptgSizes.forEach((size, index) => {\n    if (size === undefined) {\n      undefinedIndexes.push(index);\n    } else {\n      currentTotalPtg += size;\n    }\n  });\n  const restPtg = 1 - currentTotalPtg;\n  const undefinedCount = undefinedIndexes.length;\n  // If all sizes are defined but don't sum to 1, scale them.\n  if (ptgSizes.length && !undefinedIndexes.length && currentTotalPtg !== 1) {\n    // Handle the case when all sizes are 0\n    if (currentTotalPtg === 0) {\n      const avg = 1 / ptgSizes.length;\n      return ptgSizes.map(() => avg);\n    }\n    const scale = 1 / currentTotalPtg;\n    // We know `size` is a number here because undefinedIndexes is empty.\n    return ptgSizes.map(size => size * scale);\n  }\n  // Fill if exceed\n  if (restPtg < 0) {\n    const scale = 1 / currentTotalPtg;\n    return ptgSizes.map(size => size === undefined ? 0 : size * scale);\n  }\n  // Check if limit exists\n  let sumMin = 0;\n  let sumMax = 0;\n  let limitMin = 0;\n  let limitMax = 1;\n  for (const index of undefinedIndexes) {\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    sumMin += min;\n    sumMax += max;\n    limitMin = Math.max(limitMin, min);\n    limitMax = Math.min(limitMax, max);\n  }\n  // Impossible case, just average fill\n  if (sumMin > 1 && sumMax < 1) {\n    const avg = 1 / undefinedCount;\n    return ptgSizes.map(size => size === undefined ? avg : size);\n  }\n  // Quickly fill if can\n  const restAvg = restPtg / undefinedCount;\n  if (limitMin <= restAvg && restAvg <= limitMax) {\n    return ptgSizes.map(size => size === undefined ? restAvg : size);\n  }\n  // Greedy algorithm\n  const result = _toConsumableArray(ptgSizes);\n  let remain = restPtg - sumMin;\n  for (let i = 0; i < undefinedCount; i += 1) {\n    const index = undefinedIndexes[i];\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    result[index] = min;\n    const canAdd = max - min;\n    const add = Math.min(canAdd, remain);\n    result[index] += add;\n    remain -= add;\n  }\n  return result;\n}"],"mappings":"AAAA,OAAOA,kBAAkB,MAAM,8CAA8C;AAC7E,OAAO,SAASC,YAAYA,CAACC,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAE;EAC/D;EACA,IAAIC,eAAe,GAAG,CAAC;EACvB,MAAMC,gBAAgB,GAAG,EAAE;EAC3BJ,QAAQ,CAACK,OAAO,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAK;IAChC,IAAID,IAAI,KAAKE,SAAS,EAAE;MACtBJ,gBAAgB,CAACK,IAAI,CAACF,KAAK,CAAC;IAC9B,CAAC,MAAM;MACLJ,eAAe,IAAIG,IAAI;IACzB;EACF,CAAC,CAAC;EACF,MAAMI,OAAO,GAAG,CAAC,GAAGP,eAAe;EACnC,MAAMQ,cAAc,GAAGP,gBAAgB,CAACQ,MAAM;EAC9C;EACA,IAAIZ,QAAQ,CAACY,MAAM,IAAI,CAACR,gBAAgB,CAACQ,MAAM,IAAIT,eAAe,KAAK,CAAC,EAAE;IACxE;IACA,IAAIA,eAAe,KAAK,CAAC,EAAE;MACzB,MAAMU,GAAG,GAAG,CAAC,GAAGb,QAAQ,CAACY,MAAM;MAC/B,OAAOZ,QAAQ,CAACc,GAAG,CAAC,MAAMD,GAAG,CAAC;IAChC;IACA,MAAME,KAAK,GAAG,CAAC,GAAGZ,eAAe;IACjC;IACA,OAAOH,QAAQ,CAACc,GAAG,CAACR,IAAI,IAAIA,IAAI,GAAGS,KAAK,CAAC;EAC3C;EACA;EACA,IAAIL,OAAO,GAAG,CAAC,EAAE;IACf,MAAMK,KAAK,GAAG,CAAC,GAAGZ,eAAe;IACjC,OAAOH,QAAQ,CAACc,GAAG,CAACR,IAAI,IAAIA,IAAI,KAAKE,SAAS,GAAG,CAAC,GAAGF,IAAI,GAAGS,KAAK,CAAC;EACpE;EACA;EACA,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAIC,QAAQ,GAAG,CAAC;EAChB,KAAK,MAAMZ,KAAK,IAAIH,gBAAgB,EAAE;IACpC,MAAMgB,GAAG,GAAGnB,WAAW,CAACM,KAAK,CAAC,IAAI,CAAC;IACnC,MAAMc,GAAG,GAAGnB,WAAW,CAACK,KAAK,CAAC,IAAI,CAAC;IACnCS,MAAM,IAAII,GAAG;IACbH,MAAM,IAAII,GAAG;IACbH,QAAQ,GAAGI,IAAI,CAACD,GAAG,CAACH,QAAQ,EAAEE,GAAG,CAAC;IAClCD,QAAQ,GAAGG,IAAI,CAACF,GAAG,CAACD,QAAQ,EAAEE,GAAG,CAAC;EACpC;EACA;EACA,IAAIL,MAAM,GAAG,CAAC,IAAIC,MAAM,GAAG,CAAC,EAAE;IAC5B,MAAMJ,GAAG,GAAG,CAAC,GAAGF,cAAc;IAC9B,OAAOX,QAAQ,CAACc,GAAG,CAACR,IAAI,IAAIA,IAAI,KAAKE,SAAS,GAAGK,GAAG,GAAGP,IAAI,CAAC;EAC9D;EACA;EACA,MAAMiB,OAAO,GAAGb,OAAO,GAAGC,cAAc;EACxC,IAAIO,QAAQ,IAAIK,OAAO,IAAIA,OAAO,IAAIJ,QAAQ,EAAE;IAC9C,OAAOnB,QAAQ,CAACc,GAAG,CAACR,IAAI,IAAIA,IAAI,KAAKE,SAAS,GAAGe,OAAO,GAAGjB,IAAI,CAAC;EAClE;EACA;EACA,MAAMkB,MAAM,GAAG1B,kBAAkB,CAACE,QAAQ,CAAC;EAC3C,IAAIyB,MAAM,GAAGf,OAAO,GAAGM,MAAM;EAC7B,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,cAAc,EAAEe,CAAC,IAAI,CAAC,EAAE;IAC1C,MAAMnB,KAAK,GAAGH,gBAAgB,CAACsB,CAAC,CAAC;IACjC,MAAMN,GAAG,GAAGnB,WAAW,CAACM,KAAK,CAAC,IAAI,CAAC;IACnC,MAAMc,GAAG,GAAGnB,WAAW,CAACK,KAAK,CAAC,IAAI,CAAC;IACnCiB,MAAM,CAACjB,KAAK,CAAC,GAAGa,GAAG;IACnB,MAAMO,MAAM,GAAGN,GAAG,GAAGD,GAAG;IACxB,MAAMQ,GAAG,GAAGN,IAAI,CAACF,GAAG,CAACO,MAAM,EAAEF,MAAM,CAAC;IACpCD,MAAM,CAACjB,KAAK,CAAC,IAAIqB,GAAG;IACpBH,MAAM,IAAIG,GAAG;EACf;EACA,OAAOJ,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}